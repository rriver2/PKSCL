{"ast":null,"code":"var $8zHUo$sortablejs = require(\"sortablejs\");\n\nvar $8zHUo$classnames = require(\"classnames\");\n\nvar $8zHUo$react = require(\"react\");\n\nvar $8zHUo$tinyinvariant = require(\"tiny-invariant\");\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function (key) {\n    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      }\n    });\n  });\n  return dest;\n}\n\n$parcel$export(module.exports, \"Sortable\", () => $882b6d93070905b3$re_export$Sortable);\n$parcel$export(module.exports, \"Direction\", () => $882b6d93070905b3$re_export$Direction);\n$parcel$export(module.exports, \"DOMRect\", () => $882b6d93070905b3$re_export$DOMRect);\n$parcel$export(module.exports, \"GroupOptions\", () => $882b6d93070905b3$re_export$GroupOptions);\n$parcel$export(module.exports, \"MoveEvent\", () => $882b6d93070905b3$re_export$MoveEvent);\n$parcel$export(module.exports, \"Options\", () => $882b6d93070905b3$re_export$Options);\n$parcel$export(module.exports, \"PullResult\", () => $882b6d93070905b3$re_export$PullResult);\n$parcel$export(module.exports, \"PutResult\", () => $882b6d93070905b3$re_export$PutResult);\n$parcel$export(module.exports, \"SortableEvent\", () => $882b6d93070905b3$re_export$SortableEvent);\n$parcel$export(module.exports, \"SortableOptions\", () => $882b6d93070905b3$re_export$SortableOptions);\n$parcel$export(module.exports, \"Utils\", () => $882b6d93070905b3$re_export$Utils);\n$parcel$export(module.exports, \"ReactSortable\", () => $7fe8e3ea572bda7a$export$11bbed9ee0012c13);\n\nfunction $eb03e74f8f7db1f3$export$1d0aa160432dfea5(node) {\n  if (node.parentElement !== null) node.parentElement.removeChild(node);\n}\n\nfunction $eb03e74f8f7db1f3$export$6d240faa51aa562f(parent, newChild, index) {\n  const refChild = parent.children[index] || null;\n  parent.insertBefore(newChild, refChild);\n}\n\nfunction $eb03e74f8f7db1f3$export$d7d742816c28cf91(customs) {\n  $eb03e74f8f7db1f3$export$77f49a256021c8de(customs);\n  $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs);\n}\n\nfunction $eb03e74f8f7db1f3$export$77f49a256021c8de(customs) {\n  customs.forEach(curr => $eb03e74f8f7db1f3$export$1d0aa160432dfea5(curr.element));\n}\n\nfunction $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs) {\n  customs.forEach(curr => {\n    $eb03e74f8f7db1f3$export$6d240faa51aa562f(curr.parentElement, curr.element, curr.oldIndex);\n  });\n}\n\nfunction $eb03e74f8f7db1f3$export$4655efe700f887a(evt, list) {\n  const mode = $eb03e74f8f7db1f3$export$1fc0f6205829e19c(evt);\n  const parentElement = {\n    parentElement: evt.from\n  };\n  let custom = [];\n\n  switch (mode) {\n    case \"normal\":\n      /* eslint-disable */\n      const item = {\n        element: evt.item,\n        newIndex: evt.newIndex,\n        oldIndex: evt.oldIndex,\n        parentElement: evt.from\n      };\n      custom = [item];\n      break;\n\n    case \"swap\":\n      const drag = {\n        element: evt.item,\n        oldIndex: evt.oldIndex,\n        newIndex: evt.newIndex,\n        ...parentElement\n      };\n      const swap = {\n        element: evt.swapItem,\n        oldIndex: evt.newIndex,\n        newIndex: evt.oldIndex,\n        ...parentElement\n      };\n      custom = [drag, swap];\n      break;\n\n    case \"multidrag\":\n      custom = evt.oldIndicies.map((curr, index) => ({\n        element: curr.multiDragElement,\n        oldIndex: curr.index,\n        newIndex: evt.newIndicies[index].index,\n        ...parentElement\n      }));\n      break;\n  }\n  /* eslint-enable */\n\n\n  const customs = $eb03e74f8f7db1f3$export$bc06a3af7dc65f53(custom, list);\n  return customs;\n}\n\nfunction $eb03e74f8f7db1f3$export$c25cf8080bd305ec(normalized, list) {\n  const a = $eb03e74f8f7db1f3$export$be2da95e6167b0bd(normalized, list);\n  const b = $eb03e74f8f7db1f3$export$eca851ee65ae17e4(normalized, a);\n  return b;\n}\n\nfunction $eb03e74f8f7db1f3$export$be2da95e6167b0bd(normalized, list) {\n  const newList = [...list];\n  normalized.concat().reverse().forEach(curr => newList.splice(curr.oldIndex, 1));\n  return newList;\n}\n\nfunction $eb03e74f8f7db1f3$export$eca851ee65ae17e4(normalized, list, evt, clone) {\n  const newList = [...list];\n  normalized.forEach(curr => {\n    const newItem = clone && evt && clone(curr.item, evt);\n    newList.splice(curr.newIndex, 0, newItem || curr.item);\n  });\n  return newList;\n}\n\nfunction $eb03e74f8f7db1f3$export$1fc0f6205829e19c(evt) {\n  if (evt.oldIndicies && evt.oldIndicies.length > 0) return \"multidrag\";\n  if (evt.swapItem) return \"swap\";\n  return \"normal\";\n}\n\nfunction $eb03e74f8f7db1f3$export$bc06a3af7dc65f53(inputs, list) {\n  const normalized = inputs.map(curr => ({ ...curr,\n    item: list[curr.oldIndex]\n  })).sort((a, b) => a.oldIndex - b.oldIndex);\n  return normalized;\n}\n\nfunction $eb03e74f8f7db1f3$export$7553c81e62e31b7e(props) {\n  /* eslint-disable */\n  const {\n    list: // react sortable props\n    list,\n    setList: setList,\n    children: children,\n    tag: tag,\n    style: style,\n    className: className,\n    clone: clone,\n    onAdd: // sortable options that have methods we want to overwrite\n    onAdd,\n    onChange: onChange,\n    onChoose: onChoose,\n    onClone: onClone,\n    onEnd: onEnd,\n    onFilter: onFilter,\n    onRemove: onRemove,\n    onSort: onSort,\n    onStart: onStart,\n    onUnchoose: onUnchoose,\n    onUpdate: onUpdate,\n    onMove: onMove,\n    onSpill: onSpill,\n    onSelect: onSelect,\n    onDeselect: onDeselect,\n    ...options\n  } = props;\n  /* eslint-enable */\n\n  return options;\n}\n/** Holds a global reference for which react element is being dragged */\n// @todo - use context to manage this. How does one use 2 different providers?\n\n\nconst $7fe8e3ea572bda7a$var$store = {\n  dragging: null\n};\n\nclass $7fe8e3ea572bda7a$export$11bbed9ee0012c13 extends $8zHUo$react.Component {\n  constructor(props) {\n    super(props); // @todo forward ref this component\n\n    this.ref = /*#__PURE__*/$8zHUo$react.createRef(); // make all state false because we can't change sortable unless a mouse gesture is made.\n\n    const newList = [...props.list];\n    newList.forEach(item => {\n      Object.assign(item, {\n        chosen: false,\n        selected: false\n      });\n    });\n    props.setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n    $parcel$interopDefault($8zHUo$tinyinvariant)( //@ts-expect-error: Doesn't exist. Will deprecate soon.\n    !props.plugins, `\nPlugins prop is no longer supported.\nInstead, mount it with \"Sortable.mount(new MultiDrag())\"\nPlease read the updated README.md at https://github.com/SortableJS/react-sortablejs.\n      `);\n  }\n\n  componentDidMount() {\n    if (this.ref.current === null) return;\n    const newOptions = this.makeOptions();\n    $parcel$interopDefault($8zHUo$sortablejs).create(this.ref.current, newOptions);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.disabled !== this.props.disabled && this.sortable) this.sortable.option(\"disabled\", this.props.disabled);\n  }\n\n  render() {\n    const {\n      tag: tag,\n      style: style,\n      className: className,\n      id: id\n    } = this.props;\n    const classicProps = {\n      style: style,\n      className: className,\n      id: id\n    }; // if no tag, default to a `div` element.\n\n    const newTag = !tag || tag === null ? \"div\" : tag;\n    return /*#__PURE__*/$8zHUo$react.createElement(newTag, {\n      // @todo - find a way (perhaps with the callback) to allow AntD components to work\n      ref: this.ref,\n      ...classicProps\n    }, this.getChildren());\n  }\n\n  getChildren() {\n    const {\n      children: children,\n      dataIdAttr: dataIdAttr,\n      selectedClass = \"sortable-selected\",\n      chosenClass = \"sortable-chosen\",\n\n      /* eslint-disable */\n      dragClass = \"sortable-drag\",\n      fallbackClass = \"sortable-falback\",\n      ghostClass = \"sortable-ghost\",\n      swapClass = \"sortable-swap-highlight\",\n\n      /* eslint-enable */\n      filter = \"sortable-filter\",\n      list: list\n    } = this.props; // if no children, don't do anything.\n\n    if (!children || children == null) return null;\n    const dataid = dataIdAttr || \"data-id\";\n    /* eslint-disable-next-line */\n\n    return $8zHUo$react.Children.map(children, (child, index) => {\n      if (child === undefined) return undefined;\n      const item = list[index] || {};\n      const {\n        className: prevClassName\n      } = child.props; // @todo - handle the function if avalable. I don't think anyone will be doing this soon.\n\n      const filtered = typeof filter === \"string\" && {\n        [filter.replace(\".\", \"\")]: !!item.filtered\n      };\n      const className = $parcel$interopDefault($8zHUo$classnames)(prevClassName, {\n        [selectedClass]: item.selected,\n        [chosenClass]: item.chosen,\n        ...filtered\n      });\n      return /*#__PURE__*/$8zHUo$react.cloneElement(child, {\n        [dataid]: child.key,\n        className: className\n      });\n    });\n  }\n  /** Appends the `sortable` property to this component */\n\n\n  get sortable() {\n    const el = this.ref.current;\n    if (el === null) return null;\n    const key = Object.keys(el).find(k => k.includes(\"Sortable\"));\n    if (!key) return null; //@ts-expect-error: fix me.\n\n    return el[key];\n  }\n  /** Converts all the props from `ReactSortable` into the `options` object that `Sortable.create(el, [options])` can use. */\n\n\n  makeOptions() {\n    const DOMHandlers = [\"onAdd\", \"onChoose\", \"onDeselect\", \"onEnd\", \"onRemove\", \"onSelect\", \"onSpill\", \"onStart\", \"onUnchoose\", \"onUpdate\"];\n    const NonDOMHandlers = [\"onChange\", \"onClone\", \"onFilter\", \"onSort\"];\n    const newOptions = $eb03e74f8f7db1f3$export$7553c81e62e31b7e(this.props);\n    DOMHandlers.forEach(name => newOptions[name] = this.prepareOnHandlerPropAndDOM(name));\n    NonDOMHandlers.forEach(name => newOptions[name] = this.prepareOnHandlerProp(name));\n    /** onMove has 2 arguments and needs to be handled seperately. */\n\n    const onMove1 = (evt, originalEvt) => {\n      const {\n        onMove: onMove\n      } = this.props;\n      const defaultValue = evt.willInsertAfter || -1;\n      if (!onMove) return defaultValue;\n      const result = onMove(evt, originalEvt, this.sortable, $7fe8e3ea572bda7a$var$store);\n      if (typeof result === \"undefined\") return false;\n      return result;\n    };\n\n    return { ...newOptions,\n      onMove: onMove1\n    };\n  }\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop & an `on[Handler]` ReactSortable method.  */\n\n\n  prepareOnHandlerPropAndDOM(evtName) {\n    return evt => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName); // calls state change\n      //@ts-expect-error: until @types multidrag item is in\n\n      this[evtName](evt);\n    };\n  }\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop */\n\n\n  prepareOnHandlerProp(evtName) {\n    return evt => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n    };\n  }\n  /** Calls the `props.on[Handler]` function */\n\n\n  callOnHandlerProp(evt, evtName) {\n    const propEvent = this.props[evtName];\n    if (propEvent) propEvent(evt, this.sortable, $7fe8e3ea572bda7a$var$store);\n  } // SORTABLE DOM HANDLING\n\n\n  onAdd(evt) {\n    const {\n      list: list,\n      setList: setList,\n      clone: clone\n    } = this.props;\n    /* eslint-disable-next-line */\n\n    const otherList = [...$7fe8e3ea572bda7a$var$store.dragging.props.list];\n    const customs = $eb03e74f8f7db1f3$export$4655efe700f887a(evt, otherList);\n    $eb03e74f8f7db1f3$export$77f49a256021c8de(customs);\n    const newList = $eb03e74f8f7db1f3$export$eca851ee65ae17e4(customs, list, evt, clone);\n    newList.forEach(item => {\n      Object.assign(item, {\n        selected: false\n      });\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onRemove(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const mode = $eb03e74f8f7db1f3$export$1fc0f6205829e19c(evt);\n    const customs = $eb03e74f8f7db1f3$export$4655efe700f887a(evt, list);\n    $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs);\n    let newList = [...list]; // remove state if not in clone mode. otherwise, keep.\n\n    if (evt.pullMode !== \"clone\") newList = $eb03e74f8f7db1f3$export$be2da95e6167b0bd(customs, newList);else {\n      // switch used to get the clone\n      let customClones = customs;\n\n      switch (mode) {\n        case \"multidrag\":\n          customClones = customs.map((item, index) => ({ ...item,\n            element: evt.clones[index]\n          }));\n          break;\n\n        case \"normal\":\n          customClones = customs.map(item => ({ ...item,\n            element: evt.clone\n          }));\n          break;\n\n        case \"swap\":\n        default:\n          $parcel$interopDefault($8zHUo$tinyinvariant)(true, `mode \"${mode}\" cannot clone. Please remove \"props.clone\" from <ReactSortable/> when using the \"${mode}\" plugin`);\n      }\n\n      $eb03e74f8f7db1f3$export$77f49a256021c8de(customClones); // replace selected items with cloned items\n\n      customs.forEach(curr => {\n        const index = curr.oldIndex;\n        /* eslint-disable-next-line */\n\n        const newItem = this.props.clone(curr.item, evt);\n        newList.splice(index, 1, newItem);\n      });\n    } // remove item.selected from list\n\n    newList.forEach(item => {\n      Object.assign(item, {\n        selected: false\n      });\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onUpdate(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const customs = $eb03e74f8f7db1f3$export$4655efe700f887a(evt, list);\n    $eb03e74f8f7db1f3$export$77f49a256021c8de(customs);\n    $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs);\n    const newList = $eb03e74f8f7db1f3$export$c25cf8080bd305ec(customs, list);\n    return setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onStart() {\n    $7fe8e3ea572bda7a$var$store.dragging = this;\n  }\n\n  onEnd() {\n    $7fe8e3ea572bda7a$var$store.dragging = null;\n  }\n\n  onChoose(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = list.map((item, index) => {\n      if (index === evt.oldIndex) Object.assign(item, {\n        chosen: true\n      });\n      return item;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onUnchoose(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = list.map((item, index) => {\n      if (index === evt.oldIndex) Object.assign(item, {\n        chosen: false\n      });\n      return item;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onSpill(evt) {\n    const {\n      removeOnSpill: removeOnSpill,\n      revertOnSpill: revertOnSpill\n    } = this.props;\n    if (removeOnSpill && !revertOnSpill) $eb03e74f8f7db1f3$export$1d0aa160432dfea5(evt.item);\n  }\n\n  onSelect(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = [...list];\n    newList.forEach(item => {\n      Object.assign(item, {\n        chosen: false\n      });\n    });\n    evt.newIndicies.forEach(curr => {\n      const index = curr.index;\n\n      if (index === -1) {\n        console.log(`\"${evt.type}\" had indice of \"${curr.index}\", which is probably -1 and doesn't usually happen here.`);\n        console.log(evt);\n        return;\n      }\n\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onDeselect(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = [...list];\n    newList.forEach(item => {\n      Object.assign(item, {\n        chosen: false\n      });\n    });\n    evt.newIndicies.forEach(curr => {\n      const index = curr.index;\n      if (index === -1) return;\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n}\n\n$7fe8e3ea572bda7a$export$11bbed9ee0012c13.defaultProps = {\n  clone: item => item\n};\nvar $faefaad95e5fcca0$exports = {};\n$parcel$exportWildcard(module.exports, $faefaad95e5fcca0$exports);","map":{"version":3,"sources":["/Users/river2/Desktop/PKSCL/frontend/node_modules/react-sortablejs/dist/src/react-sortable.tsx","/Users/river2/Desktop/PKSCL/frontend/node_modules/react-sortablejs/dist/src/util.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SCSgB,yC,CAAW,I,EAAyB;AAClD,MAAI,IAAI,CAAC,aAAL,KAAuB,IAA3B,EAAiC,IAAI,CAAC,aAAL,CAAmB,WAAnB,CAA+B,IAA/B;AAClC;;SAQe,yC,CACd,M,EACA,Q,EACA,K,EACM;AACN,QAAM,QAAQ,GAAG,MAAM,CAAC,QAAP,CAAgB,KAAhB,KAA0B,IAA3C;AACA,EAAA,MAAM,CAAC,YAAP,CAAoB,QAApB,EAA8B,QAA9B;AACD;;SAMe,yC,CACd,O,EACM;AACN,EAAA,yCAAW,CAAC,OAAD,CAAX;AACA,EAAA,yCAAW,CAAC,OAAD,CAAX;AACD;;SAEe,yC,CACd,O,EACM;AACN,EAAA,OAAO,CAAC,OAAR,CAAiB,IAAF,IAAW,yCAAU,CAAC,IAAI,CAAC,OAAN,CAApC;AACD;;SAEe,yC,CACd,O,EACM;AACN,EAAA,OAAO,CAAC,OAAR,CAAiB,IAAF,IAAW;AACxB,IAAA,yCAAY,CAAC,IAAI,CAAC,aAAN,EAAqB,IAAI,CAAC,OAA1B,EAAmC,IAAI,CAAC,QAAxC,CAAZ;AACD,GAFD;AAGD;;SAEe,wC,CACd,G,EACA,I,EACiB;AACjB,QAAM,IAAI,GAAG,yCAAO,CAAC,GAAD,CAApB;AACA,QAAM,aAAa,GAAG;AAAE,IAAA,aAAa,EAAE,GAAG,CAAC;AAArB,GAAtB;AACA,MAAI,MAAM,GAAG,EAAb;;AACA,UAAQ,IAAR;AACE,SAAK,QAAL;AACE;AACA,YAAM,IAAI,GAAG;AACX,QAAA,OAAO,EAAE,GAAG,CAAC,IADF;AAEX,QAAA,QAAQ,EAAE,GAAG,CAAC,QAFH;AAGX,QAAA,QAAQ,EAAE,GAAG,CAAC,QAHH;AAIX,QAAA,aAAa,EAAE,GAAG,CAAC;AAJR,OAAb;AAMA,MAAA,MAAM,GAAG,CAAC,IAAD,CAAT;AACA;;AACF,SAAK,MAAL;AACE,YAAM,IAAI,GAAU;AAClB,QAAA,OAAO,EAAE,GAAG,CAAC,IADK;AAElB,QAAA,QAAQ,EAAE,GAAG,CAAC,QAFI;AAGlB,QAAA,QAAQ,EAAE,GAAG,CAAC,QAHI;WAIf;AAJe,OAApB;AAMA,YAAM,IAAI,GAAU;AAClB,QAAA,OAAO,EAAE,GAAG,CAAC,QADK;AAElB,QAAA,QAAQ,EAAE,GAAG,CAAC,QAFI;AAGlB,QAAA,QAAQ,EAAE,GAAG,CAAC,QAHI;WAIf;AAJe,OAApB;AAMA,MAAA,MAAM,GAAG,CAAC,IAAD,EAAO,IAAP,CAAT;AACA;;AACF,SAAK,WAAL;AACE,MAAA,MAAM,GAAG,GAAG,CAAC,WAAJ,CAAgB,GAAhB,CAAmB,CAAS,IAAT,EAAe,KAAf,MAA0B;AACpD,QAAA,OAAO,EAAE,IAAI,CAAC,gBADsC;AAEpD,QAAA,QAAQ,EAAE,IAAI,CAAC,KAFqC;AAGpD,QAAA,QAAQ,EAAE,GAAG,CAAC,WAAJ,CAAgB,KAAhB,EAAuB,KAHmB;WAIjD;AAJiD,OAA1B,CAAnB,CAAT;AAMA;AAjCJ;AAmCA;;;AAEA,QAAM,OAAO,GAAG,yCAAgB,CAAC,MAAD,EAAS,IAAT,CAAhC;AACA,SAAO,OAAP;AACD;;SAGe,yC,CACd,U,EACA,I,EACK;AACL,QAAM,CAAC,GAAG,yCAAiB,CAAC,UAAD,EAAa,IAAb,CAA3B;AACA,QAAM,CAAC,GAAG,yCAAc,CAAC,UAAD,EAAa,CAAb,CAAxB;AACA,SAAO,CAAP;AACD;;SAEe,yC,CACd,U,EACA,I,EACK;AACL,QAAM,OAAO,GAAG,C,GAAI,IAAJ,CAAhB;AACA,EAAA,UAAU,CACP,MADH,GAEG,OAFH,GAGG,OAHH,CAGY,IAAF,IAAW,OAAO,CAAC,MAAR,CAAe,IAAI,CAAC,QAApB,EAA8B,CAA9B,CAHrB;AAIA,SAAO,OAAP;AACD;;SAEe,yC,CACd,U,EACA,I,EACA,G,EACA,K,EACK;AACL,QAAM,OAAO,GAAG,C,GAAI,IAAJ,CAAhB;AACA,EAAA,UAAU,CAAC,OAAX,CAAoB,IAAF,IAAW;AAC3B,UAAM,OAAO,GAAG,KAAK,IAAI,GAAT,IAAgB,KAAK,CAAC,IAAI,CAAC,IAAN,EAAY,GAAZ,CAArC;AACA,IAAA,OAAO,CAAC,MAAR,CAAe,IAAI,CAAC,QAApB,EAA8B,CAA9B,EAAiC,OAAO,IAAI,IAAI,CAAC,IAAjD;AACD,GAHD;AAIA,SAAO,OAAP;AACD;;SAEe,yC,CAAQ,G,EAAsD;AAC5E,MAAI,GAAG,CAAC,WAAJ,IAAmB,GAAG,CAAC,WAAJ,CAAgB,MAAhB,GAAyB,CAAhD,EAAmD,OAAO,WAAP;AACnD,MAAI,GAAG,CAAC,QAAR,EAAkB,OAAO,MAAP;AAClB,SAAO,QAAP;AACD;;SAEe,yC,CACd,M,EACA,I,EACiB;AACjB,QAAM,UAAU,GAAG,MAAM,CACtB,GADgB,CACI,IAAjB,KAA2B,E,GAAK,IAAL;AAAW,IAAA,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,QAAN;AAArB,GAA3B,CADa,EAEhB,IAFgB,CAEZ,CAAE,CAAF,EAAK,CAAL,KAAW,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,QAFd,CAAnB;AAGA,SAAO,UAAP;AACD;;SAkBe,yC,CACd,K,EACkC;AAClC;AACA,QAAM;AAAC,IAAA,IAAA,EACL;AACA,IAAA,IAFI;AAEA,IAAA,OAAA,EACJ,OAHI;AAGG,IAAA,QAAA,EACP,QAJI;AAII,IAAA,GAAA,EACR,GALI;AAKD,IAAA,KAAA,EACH,KANI;AAMC,IAAA,SAAA,EACL,SAPI;AAOK,IAAA,KAAA,EACT,KARI;AAQC,IAAA,KAAA,EACL;AACA,IAAA,KAVI;AAUC,IAAA,QAAA,EACL,QAXI;AAWI,IAAA,QAAA,EACR,QAZI;AAYI,IAAA,OAAA,EACR,OAbI;AAaG,IAAA,KAAA,EACP,KAdI;AAcC,IAAA,QAAA,EACL,QAfI;AAeI,IAAA,QAAA,EACR,QAhBI;AAgBI,IAAA,MAAA,EACR,MAjBI;AAiBE,IAAA,OAAA,EACN,OAlBI;AAkBG,IAAA,UAAA,EACP,UAnBI;AAmBM,IAAA,QAAA,EACV,QApBI;AAoBI,IAAA,MAAA,EACR,MArBI;AAqBE,IAAA,OAAA,EACN,OAtBI;AAsBG,IAAA,QAAA,EACP,QAvBI;AAuBI,IAAA,UAAA,EACR,UAxBI;AAwBM,OACP;AAzBC,MA0BF,KA1BJ;AA2BA;;AACA,SAAO,OAAP;AACD;AD1KD;AACA;;;AACA,MAAM,2BAAK,GAAU;AAAE,EAAA,QAAQ,EAAE;AAAZ,CAArB;;MAEa,yC,SAA+C,YAAA,CAAA,S,CAAS;cASvD,K,EAA8B;AACxC,UAAM,KAAN,EADwC,CAExC;;AACA,SAAK,GAAL,GAAQ,aAAG,YAAA,CAAA,SAAA,EAAX,CAHwC,CAKxC;;AACA,UAAM,OAAO,GAAG,C,GAAI,KAAK,CAAC,IAAV,CAAhB;AAEA,IAAA,OAAO,CAAC,OAAR,CAAiB,IAAF,IAAc;AAC3B,MAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB;AAClB,QAAA,MAAM,EAAE,KADU;AAElB,QAAA,QAAQ,EAAE;AAFQ,OAApB;AAID,KALD;AAOA,IAAA,KAAK,CAAC,OAAN,CAAc,OAAd,EAAuB,KAAK,QAA5B,EAAsC,2BAAtC;AACA,IAAA,sBAAA,CAAA,oBAAA,CAAA,EACE;KACC,KAAK,CAAC,OAFT,EAGG;;;;AAID,OAPF;AASD;;AAED,EAAA,iBAAiB,GAAS;AACxB,QAAI,KAAK,GAAL,CAAS,OAAT,KAAqB,IAAzB,EAA+B;AAC/B,UAAM,UAAU,GAAG,KAAK,WAAL,EAAnB;AACA,IAAA,sBAAA,CAAA,iBAAA,CAAA,CAAS,MAAT,CAAgB,KAAK,GAAL,CAAS,OAAzB,EAAkC,UAAlC;AACD;;AAED,EAAA,kBAAkB,CAAC,SAAD,EAAyC;AACzD,QAAI,SAAS,CAAC,QAAV,KAAuB,KAAK,KAAL,CAAW,QAAlC,IAA8C,KAAK,QAAvD,EACE,KAAK,QAAL,CAAc,MAAd,CAAqB,UAArB,EAAiC,KAAK,KAAL,CAAW,QAA5C;AAEH;;AAED,EAAA,MAAM,GAAgB;AACpB,UAAM;AAAC,MAAA,GAAA,EAAC,GAAF;AAAK,MAAA,KAAA,EAAE,KAAP;AAAY,MAAA,SAAA,EAAE,SAAd;AAAuB,MAAA,EAAA,EAAE;AAAzB,QAAgC,KAAK,KAA3C;AACA,UAAM,YAAY,GAAG;aAAE,KAAF;iBAAS,SAAT;UAAoB;AAApB,KAArB,CAFoB,CAIpB;;AACA,UAAM,MAAM,GAAA,CAAI,GAAJ,IAAW,GAAG,KAAK,IAAnB,GAA0B,KAA1B,GAAkC,GAA9C;AACA,WAAM,aAAC,YAAA,CAAA,aAAA,CACL,MADK,EAEL;AACE;AACA,MAAA,GAAG,EAAE,KAAK,GAFZ;SAGK;AAHL,KAFK,EAOL,KAAK,WAAL,EAPK,CAAP;AASD;;AAEO,EAAA,WAAW,GAAG;AACpB,UAAM;AAAC,MAAA,QAAA,EACL,QADI;AACI,MAAA,UAAA,EACR,UAFI;AAGJ,MAAA,aAAa,GAAG,mBAHZ;AAIJ,MAAA,WAAW,GAAG,iBAJV;;AAKJ;AACA,MAAA,SAAS,GAAG,eANR;AAOJ,MAAA,aAAa,GAAG,kBAPZ;AAQJ,MAAA,UAAU,GAAG,gBART;AASJ,MAAA,SAAS,GAAG,yBATR;;AAUJ;AACA,MAAA,MAAM,GAAG,iBAXL;AAWsB,MAAA,IAAA,EAC1B;AAZI,QAaF,KAAK,KAbT,CADoB,CAgBpB;;AACA,QAAE,CAAG,QAAH,IAAe,QAAQ,IAAI,IAA7B,EAAmC,OAAO,IAAP;AACnC,UAAM,MAAM,GAAG,UAAU,IAAI,SAA7B;AACA;;AACA,WAAO,YAAA,CAAA,QAAA,CAAS,GAAT,CAAa,QAAb,EAAqB,CAA0B,KAA1B,EAAiC,KAAjC,KAA2C;AACrE,UAAI,KAAK,KAAK,SAAd,EAAyB,OAAO,SAAP;AAEzB,YAAM,IAAI,GAAG,IAAI,CAAC,KAAD,CAAJ,IAAe,EAA5B;AACA,YAAM;AAAE,QAAA,SAAS,EAAE;AAAb,UAA+B,KAAK,CAAC,KAA3C,CAJqE,CAMrE;;AACA,YAAM,QAAQ,GAAG,OAAO,MAAP,KAAkB,QAAlB,IAA8B;SAC5C,MAAM,CAAC,OAAP,CAAe,GAAf,EAAoB,EAApB,C,GAAsB,CAAA,CAAM,IAAI,CAAC;AADW,OAA/C;AAIA,YAAM,SAAS,GAAG,sBAAA,CAAA,iBAAA,CAAA,CAAW,aAAX,EAA0B;SACzC,a,GAAgB,IAAI,CAAC,QADoB;SAEzC,W,GAAc,IAAI,CAAC,MAFsB;WAGvC;AAHuC,OAA1B,CAAlB;AAUA,aAAM,aAAC,YAAA,CAAA,YAAA,CAAa,KAAb,EAAoB;SACxB,M,GAAS,KAAK,CAAC,GADS;mBAEzB;AAFyB,OAApB,CAAP;AAID,KAzBM,CAAP;AA0BD;AAED;;;AACoB,MAAR,QAAQ,GAAoB;AACtC,UAAM,EAAE,GAAG,KAAK,GAAL,CAAS,OAApB;AACA,QAAI,EAAE,KAAK,IAAX,EAAiB,OAAO,IAAP;AACjB,UAAM,GAAG,GAAG,MAAM,CAAC,IAAP,CAAY,EAAZ,EAAgB,IAAhB,CAAsB,CAAF,IAAQ,CAAC,CAAC,QAAF,CAAW,UAAX,CAA5B,CAAZ;AACA,QAAE,CAAG,GAAL,EAAU,OAAO,IAAP,CAJ4B,CAKtC;;AACA,WAAO,EAAE,CAAC,GAAD,CAAT;AACD;AAED;;;AACA,EAAA,WAAW,GAAY;AACrB,UAAM,WAAW,GAAyB,CACxC,OADwC,EAExC,UAFwC,EAGxC,YAHwC,EAIxC,OAJwC,EAKxC,UALwC,EAMxC,UANwC,EAOxC,SAPwC,EAQxC,SARwC,EASxC,YATwC,EAUxC,UAVwC,CAA1C;AAYA,UAAM,cAAc,GAA2B,CAC7C,UAD6C,EAE7C,SAF6C,EAG7C,UAH6C,EAI7C,QAJ6C,CAA/C;AAMA,UAAM,UAAU,GAAY,yCAA0B,CAAC,KAAK,KAAN,CAAtD;AACA,IAAA,WAAW,CAAC,OAAZ,CACG,IADgB,IACN,UAAU,CAAC,IAAD,CAAV,GAAmB,KAAK,0BAAL,CAAgC,IAAhC,CADhC;AAGA,IAAA,cAAc,CAAC,OAAf,CACG,IADmB,IACT,UAAU,CAAC,IAAD,CAAV,GAAmB,KAAK,oBAAL,CAA0B,IAA1B,CADhC;AAIA;;AACA,UAAM,OAAM,GAAA,CAAI,GAAJ,EAAoB,WAApB,KAA2C;AACrD,YAAM;AAAC,QAAA,MAAA,EAAC;AAAF,UAAa,KAAK,KAAxB;AACA,YAAM,YAAY,GAAG,GAAG,CAAC,eAAJ,IAAuB,CAAA,CAA5C;AACA,UAAE,CAAG,MAAL,EAAa,OAAO,YAAP;AACb,YAAM,MAAM,GAAG,MAAM,CAAC,GAAD,EAAM,WAAN,EAAmB,KAAK,QAAxB,EAAkC,2BAAlC,CAArB;AACA,UAAI,OAAO,MAAP,KAAkB,WAAtB,EAAmC,OAAO,KAAP;AACnC,aAAO,MAAP;AACD,KAPD;;AASA,WAAO,E,GACF,UADE;cAEL;AAFK,KAAP;AAID;AAED;;;AACA,EAAA,0BAA0B,CACxB,OADwB,EAEM;AAC9B,WAAQ,GAAF,IAAU;AACd;AACA,WAAK,iBAAL,CAAuB,GAAvB,EAA4B,OAA5B,EAFc,CAGd;AACA;;AACA,WAAK,OAAL,EAAc,GAAd;AACD,KAND;AAOD;AAED;;;AACA,EAAA,oBAAoB,CAClB,OADkB,EAEY;AAC9B,WAAQ,GAAF,IAAU;AACd;AACA,WAAK,iBAAL,CAAuB,GAAvB,EAA4B,OAA5B;AACD,KAHD;AAID;AAED;;;AACA,EAAA,iBAAiB,CAAC,GAAD,EAAqB,OAArB,EAA0D;AACzE,UAAM,SAAS,GAAG,KAAK,KAAL,CAAW,OAAX,CAAlB;AACA,QAAI,SAAJ,EAAe,SAAS,CAAC,GAAD,EAAM,KAAK,QAAX,EAAqB,2BAArB,CAAT;AAChB,GAlMkE,CAoMnE;;;AAEA,EAAA,KAAK,CAAC,GAAD,EAA4B;AAC/B,UAAM;AAAC,MAAA,IAAA,EAAC,IAAF;AAAM,MAAA,OAAA,EAAE,OAAR;AAAe,MAAA,KAAA,EAAE;AAAjB,QAA2B,KAAK,KAAtC;AACA;;AACA,UAAM,SAAS,GAAG,C,GAAI,2BAAK,CAAC,QAAN,CAAgB,KAAhB,CAAsB,IAA1B,CAAlB;AACA,UAAM,OAAO,GAAG,wCAAa,CAAC,GAAD,EAAM,SAAN,CAA7B;AACA,IAAA,yCAAW,CAAC,OAAD,CAAX;AAEA,UAAM,OAAO,GAAG,yCAAc,CAAC,OAAD,EAAU,IAAV,EAAgB,GAAhB,EAAqB,KAArB,CAA9B;AAEA,IAAA,OAAO,CAAC,OAAR,CAAiB,IAAF,IAAW;AACxB,MAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB;AAClB,QAAA,QAAQ,EAAE;AADQ,OAApB;AAGD,KAJD;AAKA,IAAA,OAAO,CAAC,OAAD,EAAU,KAAK,QAAf,EAAyB,2BAAzB,CAAP;AACD;;AAED,EAAA,QAAQ,CAAC,GAAD,EAA4B;AAClC,UAAM;AAAC,MAAA,IAAA,EAAC,IAAF;AAAM,MAAA,OAAA,EAAE;AAAR,QAAoB,KAAK,KAA/B;AACA,UAAM,IAAI,GAAG,yCAAO,CAAC,GAAD,CAApB;AACA,UAAM,OAAO,GAAG,wCAAa,CAAC,GAAD,EAAM,IAAN,CAA7B;AACA,IAAA,yCAAW,CAAC,OAAD,CAAX;AAEA,QAAI,OAAO,GAAG,C,GAAI,IAAJ,CAAd,CANkC,CAOlC;;AACA,QAAI,GAAG,CAAC,QAAJ,KAAiB,OAArB,EAA8B,OAAO,GAAG,yCAAiB,CAAC,OAAD,EAAU,OAAV,CAA3B,CAA9B,KAGK;AACH;AACA,UAAI,YAAY,GAAG,OAAnB;;AACA,cAAQ,IAAR;AACE,aAAK,WAAL;AACE,UAAA,YAAY,GAAG,OAAO,CAAC,GAAR,CAAW,CAAE,IAAF,EAAQ,KAAR,MAAmB,E,GACxC,IADwC;AAE3C,YAAA,OAAO,EAAE,GAAG,CAAC,MAAJ,CAAW,KAAX;AAFkC,WAAnB,CAAX,CAAf;AAIA;;AACF,aAAK,QAAL;AACE,UAAA,YAAY,GAAG,OAAO,CAAC,GAAR,CAAa,IAAF,KAAY,E,GACjC,IADiC;AAEpC,YAAA,OAAO,EAAE,GAAG,CAAC;AAFuB,WAAZ,CAAX,CAAf;AAIA;;AACF,aAAK,MAAL;;AAEE,UAAA,sBAAA,CAAA,oBAAA,CAAA,CACE,IADF,EAEG,SAAQ,IAAK,qFAAoF,IAAK,UAFzG;AAfJ;;AAqBA,MAAA,yCAAW,CAAC,YAAD,CAAX,CAxBG,CA0BH;;AACA,MAAA,OAAO,CAAC,OAAR,CAAiB,IAAF,IAAW;AACxB,cAAM,KAAK,GAAG,IAAI,CAAC,QAAnB;AACA;;AACA,cAAM,OAAO,GAAG,KAAK,KAAL,CAAW,KAAX,CAAkB,IAAI,CAAC,IAAvB,EAA6B,GAA7B,CAAhB;AACA,QAAA,OAAO,CAAC,MAAR,CAAe,KAAf,EAAsB,CAAtB,EAAyB,OAAzB;AACD,OALD;AAMD,KA5CiC,CA8ClC;;AACA,IAAA,OAAO,CAAC,OAAR,CAAiB,IAAF,IAAc;AAC3B,MAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB;AAClB,QAAA,QAAQ,EAAE;AADQ,OAApB;AAGD,KAJD;AAKA,IAAA,OAAO,CAAC,OAAD,EAAU,KAAK,QAAf,EAAyB,2BAAzB,CAAP;AACD;;AAED,EAAA,QAAQ,CAAC,GAAD,EAA4B;AAClC,UAAM;AAAC,MAAA,IAAA,EAAC,IAAF;AAAM,MAAA,OAAA,EAAE;AAAR,QAAoB,KAAK,KAA/B;AACA,UAAM,OAAO,GAAG,wCAAa,CAAC,GAAD,EAAM,IAAN,CAA7B;AACA,IAAA,yCAAW,CAAC,OAAD,CAAX;AACA,IAAA,yCAAW,CAAC,OAAD,CAAX;AACA,UAAM,OAAO,GAAG,yCAAkB,CAAC,OAAD,EAAU,IAAV,CAAlC;AACA,WAAO,OAAO,CAAC,OAAD,EAAU,KAAK,QAAf,EAAyB,2BAAzB,CAAd;AACD;;AAED,EAAA,OAAO,GAAS;AACd,IAAA,2BAAK,CAAC,QAAN,GAAiB,IAAjB;AACD;;AAED,EAAA,KAAK,GAAS;AACZ,IAAA,2BAAK,CAAC,QAAN,GAAiB,IAAjB;AACD;;AAED,EAAA,QAAQ,CAAC,GAAD,EAA2B;AACjC,UAAM;AAAC,MAAA,IAAA,EAAC,IAAF;AAAM,MAAA,OAAA,EAAE;AAAR,QAAoB,KAAK,KAA/B;AACA,UAAM,OAAO,GAAG,IAAI,CAAC,GAAL,CAAQ,CAAE,IAAF,EAAQ,KAAR,KAAkB;AACxC,UAAI,KAAK,KAAK,GAAG,CAAC,QAAlB,EACE,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB;AAClB,QAAA,MAAM,EAAE;AADU,OAApB;AAIF,aAAO,IAAP;AACD,KAPe,CAAhB;AAQA,IAAA,OAAO,CAAC,OAAD,EAAU,KAAK,QAAf,EAAyB,2BAAzB,CAAP;AACD;;AAED,EAAA,UAAU,CAAC,GAAD,EAA2B;AACnC,UAAM;AAAC,MAAA,IAAA,EAAC,IAAF;AAAM,MAAA,OAAA,EAAE;AAAR,QAAoB,KAAK,KAA/B;AACA,UAAM,OAAO,GAAG,IAAI,CAAC,GAAL,CAAQ,CAAE,IAAF,EAAQ,KAAR,KAAkB;AACxC,UAAI,KAAK,KAAK,GAAG,CAAC,QAAlB,EACE,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB;AAClB,QAAA,MAAM,EAAE;AADU,OAApB;AAIF,aAAO,IAAP;AACD,KAPe,CAAhB;AAQA,IAAA,OAAO,CAAC,OAAD,EAAU,KAAK,QAAf,EAAyB,2BAAzB,CAAP;AACD;;AAED,EAAA,OAAO,CAAC,GAAD,EAA2B;AAChC,UAAM;AAAC,MAAA,aAAA,EAAC,aAAF;AAAe,MAAA,aAAA,EAAE;AAAjB,QAAmC,KAAK,KAA9C;AACA,QAAI,aAAa,IAAA,CAAK,aAAtB,EAAqC,yCAAU,CAAC,GAAG,CAAC,IAAL,CAAV;AACtC;;AAED,EAAA,QAAQ,CAAC,GAAD,EAA4B;AAClC,UAAM;AAAC,MAAA,IAAA,EAAC,IAAF;AAAM,MAAA,OAAA,EAAE;AAAR,QAAoB,KAAK,KAA/B;AACA,UAAM,OAAO,GAAG,C,GAAI,IAAJ,CAAhB;AACA,IAAA,OAAO,CAAC,OAAR,CAAiB,IAAF,IAAW;AACxB,MAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB;AAClB,QAAA,MAAM,EAAE;AADU,OAApB;AAGD,KAJD;AAKA,IAAA,GAAG,CAAC,WAAJ,CAAgB,OAAhB,CAAyB,IAAF,IAAW;AAChC,YAAM,KAAK,GAAG,IAAI,CAAC,KAAnB;;AACA,UAAI,KAAK,KAAK,CAAA,CAAd,EAAkB;AAChB,QAAA,OAAO,CAAC,GAAR,CACG,IAAG,GAAG,CAAC,IAAK,oBAAmB,IAAI,CAAC,KAAM,0DAD7C;AAGA,QAAA,OAAO,CAAC,GAAR,CAAY,GAAZ;AACA;AACD;;AACD,MAAA,OAAO,CAAC,KAAD,CAAP,CAAe,QAAf,GAA0B,IAA1B;AACD,KAVD;AAWA,IAAA,OAAO,CAAC,OAAD,EAAU,KAAK,QAAf,EAAyB,2BAAzB,CAAP;AACD;;AAED,EAAA,UAAU,CAAC,GAAD,EAA4B;AACpC,UAAM;AAAC,MAAA,IAAA,EAAC,IAAF;AAAM,MAAA,OAAA,EAAE;AAAR,QAAoB,KAAK,KAA/B;AACA,UAAM,OAAO,GAAG,C,GAAI,IAAJ,CAAhB;AACA,IAAA,OAAO,CAAC,OAAR,CAAiB,IAAF,IAAW;AACxB,MAAA,MAAM,CAAC,MAAP,CAAc,IAAd,EAAoB;AAClB,QAAA,MAAM,EAAE;AADU,OAApB;AAGD,KAJD;AAKA,IAAA,GAAG,CAAC,WAAJ,CAAgB,OAAhB,CAAyB,IAAF,IAAW;AAChC,YAAM,KAAK,GAAG,IAAI,CAAC,KAAnB;AACA,UAAI,KAAK,KAAK,CAAA,CAAd,EAAkB;AAClB,MAAA,OAAO,CAAC,KAAD,CAAP,CAAe,QAAf,GAA0B,IAA1B;AACD,KAJD;AAKA,IAAA,OAAO,CAAC,OAAD,EAAU,KAAK,QAAf,EAAyB,2BAAzB,CAAP;AACD;;AAlWkE;;AAAxD,yCAAa,CAIjB,YAJI,GAI6C;AACtD,EAAA,KAAK,EAAG,IAAH,IAAY;AADqC,CAJ7C","sourcesContent":["import classNames from \"classnames\";\nimport {\n  Children,\n  cloneElement,\n  Component,\n  createElement,\n  createRef,\n  ReactElement,\n  RefObject,\n} from \"react\";\nimport Sortable, { MoveEvent, Options, SortableEvent } from \"sortablejs\";\nimport invariant from \"tiny-invariant\";\nimport {\n  AllMethodsExceptMove,\n  HandledMethodNames,\n  ItemInterface,\n  ReactSortableProps,\n  Store,\n  UnHandledMethodNames,\n} from \"./types\";\nimport {\n  createCustoms,\n  destructurePropsForOptions,\n  getMode,\n  handleStateAdd,\n  handleStateChanges,\n  handleStateRemove,\n  insertNodes,\n  removeNode,\n  removeNodes,\n} from \"./util\";\n\n/** Holds a global reference for which react element is being dragged */\n// @todo - use context to manage this. How does one use 2 different providers?\nconst store: Store = { dragging: null };\n\nexport class ReactSortable<T extends ItemInterface> extends Component<\n  ReactSortableProps<T>\n> {\n  /* eslint-disable-next-line */\n  static defaultProps: Partial<ReactSortableProps<any>> = {\n    clone: (item) => item,\n  };\n\n  private ref: RefObject<HTMLElement>;\n  constructor(props: ReactSortableProps<T>) {\n    super(props);\n    // @todo forward ref this component\n    this.ref = createRef<HTMLElement>();\n\n    // make all state false because we can't change sortable unless a mouse gesture is made.\n    const newList = [...props.list];\n\n    newList.forEach((item: T) => {\n      Object.assign(item, {\n        chosen: false,\n        selected: false,\n      });\n    })\n\n    props.setList(newList, this.sortable, store);\n    invariant(\n      //@ts-expect-error: Doesn't exist. Will deprecate soon.\n      !props.plugins,\n      `\nPlugins prop is no longer supported.\nInstead, mount it with \"Sortable.mount(new MultiDrag())\"\nPlease read the updated README.md at https://github.com/SortableJS/react-sortablejs.\n      `\n    );\n  }\n\n  componentDidMount(): void {\n    if (this.ref.current === null) return;\n    const newOptions = this.makeOptions();\n    Sortable.create(this.ref.current, newOptions);\n  }\n\n  componentDidUpdate(prevProps: ReactSortableProps<T>): void {\n    if (prevProps.disabled !== this.props.disabled && this.sortable) {\n      this.sortable.option(\"disabled\", this.props.disabled);\n    }\n  }\n\n  render(): JSX.Element {\n    const { tag, style, className, id } = this.props;\n    const classicProps = { style, className, id };\n\n    // if no tag, default to a `div` element.\n    const newTag = !tag || tag === null ? \"div\" : tag;\n    return createElement(\n      newTag,\n      {\n        // @todo - find a way (perhaps with the callback) to allow AntD components to work\n        ref: this.ref,\n        ...classicProps,\n      },\n      this.getChildren()\n    );\n  }\n\n  private getChildren() {\n    const {\n      children,\n      dataIdAttr,\n      selectedClass = \"sortable-selected\",\n      chosenClass = \"sortable-chosen\",\n      /* eslint-disable */\n      dragClass = \"sortable-drag\",\n      fallbackClass = \"sortable-falback\",\n      ghostClass = \"sortable-ghost\",\n      swapClass = \"sortable-swap-highlight\",\n      /* eslint-enable */\n      filter = \"sortable-filter\",\n      list,\n    } = this.props;\n\n    // if no children, don't do anything.\n    if (!children || children == null) return null;\n    const dataid = dataIdAttr || \"data-id\";\n    /* eslint-disable-next-line */\n    return Children.map(children as ReactElement<any>[], (child, index) => {\n      if (child === undefined) return undefined\n      \n      const item = list[index] || {};\n      const { className: prevClassName } = child.props;\n\n      // @todo - handle the function if avalable. I don't think anyone will be doing this soon.\n      const filtered = typeof filter === \"string\" && {\n        [filter.replace(\".\", \"\")]: !!item.filtered,\n      };\n\n      const className = classNames(prevClassName, {\n        [selectedClass]: item.selected,\n        [chosenClass]: item.chosen,\n        ...filtered,\n        // [dragClass]: true,\n        // [fallbackClass]: true,\n        // [ghostClass]: true,\n        // [swapClass]: true\n      });\n\n      return cloneElement(child, {\n        [dataid]: child.key,\n        className,\n      });\n    });\n  }\n\n  /** Appends the `sortable` property to this component */\n  private get sortable(): Sortable | null {\n    const el = this.ref.current;\n    if (el === null) return null;\n    const key = Object.keys(el).find((k) => k.includes(\"Sortable\"));\n    if (!key) return null;\n    //@ts-expect-error: fix me.\n    return el[key] as Sortable;\n  }\n\n  /** Converts all the props from `ReactSortable` into the `options` object that `Sortable.create(el, [options])` can use. */\n  makeOptions(): Options {\n    const DOMHandlers: HandledMethodNames[] = [\n      \"onAdd\",\n      \"onChoose\",\n      \"onDeselect\",\n      \"onEnd\",\n      \"onRemove\",\n      \"onSelect\",\n      \"onSpill\",\n      \"onStart\",\n      \"onUnchoose\",\n      \"onUpdate\",\n    ];\n    const NonDOMHandlers: UnHandledMethodNames[] = [\n      \"onChange\",\n      \"onClone\",\n      \"onFilter\",\n      \"onSort\",\n    ];\n    const newOptions: Options = destructurePropsForOptions(this.props);\n    DOMHandlers.forEach(\n      (name) => (newOptions[name] = this.prepareOnHandlerPropAndDOM(name))\n    );\n    NonDOMHandlers.forEach(\n      (name) => (newOptions[name] = this.prepareOnHandlerProp(name))\n    );\n\n    /** onMove has 2 arguments and needs to be handled seperately. */\n    const onMove = (evt: MoveEvent, originalEvt: Event) => {\n      const { onMove } = this.props;\n      const defaultValue = evt.willInsertAfter || -1;\n      if (!onMove) return defaultValue;\n      const result = onMove(evt, originalEvt, this.sortable, store);\n      if (typeof result === \"undefined\") return false;\n      return result;\n    };\n\n    return {\n      ...newOptions,\n      onMove,\n    };\n  }\n\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop & an `on[Handler]` ReactSortable method.  */\n  prepareOnHandlerPropAndDOM(\n    evtName: HandledMethodNames\n  ): (evt: SortableEvent) => void {\n    return (evt) => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n      // calls state change\n      //@ts-expect-error: until @types multidrag item is in\n      this[evtName](evt);\n    };\n  }\n\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop */\n  prepareOnHandlerProp(\n    evtName: Exclude<AllMethodsExceptMove, HandledMethodNames>\n  ): (evt: SortableEvent) => void {\n    return (evt) => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n    };\n  }\n\n  /** Calls the `props.on[Handler]` function */\n  callOnHandlerProp(evt: SortableEvent, evtName: AllMethodsExceptMove): void {\n    const propEvent = this.props[evtName];\n    if (propEvent) propEvent(evt, this.sortable, store);\n  }\n\n  // SORTABLE DOM HANDLING\n\n  onAdd(evt: MultiDragEvent): void {\n    const { list, setList, clone } = this.props;\n    /* eslint-disable-next-line */\n    const otherList = [...store.dragging!.props.list];\n    const customs = createCustoms(evt, otherList);\n    removeNodes(customs);\n\n    const newList = handleStateAdd(customs, list, evt, clone)\n\n    newList.forEach((item) => {\n      Object.assign(item, {\n        selected: false,\n      });\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onRemove(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const mode = getMode(evt);\n    const customs = createCustoms(evt, list);\n    insertNodes(customs);\n\n    let newList = [...list];\n    // remove state if not in clone mode. otherwise, keep.\n    if (evt.pullMode !== \"clone\") newList = handleStateRemove(customs, newList);\n    // if clone, it doesn't really remove. instead it clones in place.\n    // @todo -\n    else {\n      // switch used to get the clone\n      let customClones = customs;\n      switch (mode) {\n        case \"multidrag\":\n          customClones = customs.map((item, index) => ({\n            ...item,\n            element: evt.clones[index],\n          }));\n          break;\n        case \"normal\":\n          customClones = customs.map((item) => ({\n            ...item,\n            element: evt.clone,\n          }));\n          break;\n        case \"swap\":\n        default: {\n          invariant(\n            true,\n            `mode \"${mode}\" cannot clone. Please remove \"props.clone\" from <ReactSortable/> when using the \"${mode}\" plugin`\n          );\n        }\n      }\n      removeNodes(customClones);\n\n      // replace selected items with cloned items\n      customs.forEach((curr) => {\n        const index = curr.oldIndex;\n        /* eslint-disable-next-line */\n        const newItem = this.props.clone!(curr.item, evt);\n        newList.splice(index, 1, newItem);\n      });\n    }\n\n    // remove item.selected from list\n    newList.forEach((item: T) => {\n      Object.assign(item, {\n        selected: false,\n      });\n    })\n    setList(newList, this.sortable, store);\n  }\n\n  onUpdate(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const customs = createCustoms(evt, list);\n    removeNodes(customs);\n    insertNodes(customs);\n    const newList = handleStateChanges(customs, list);\n    return setList(newList, this.sortable, store);\n  }\n\n  onStart(): void {\n    store.dragging = this;\n  }\n\n  onEnd(): void {\n    store.dragging = null;\n  }\n\n  onChoose(evt: SortableEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item, index) => {\n      if (index === evt.oldIndex) {\n        Object.assign(item, {\n          chosen: true,\n        });\n      }\n      return item;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onUnchoose(evt: SortableEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item, index) => {\n      if (index === evt.oldIndex) {\n        Object.assign(item, {\n          chosen: false,\n        });\n      }\n      return item;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onSpill(evt: SortableEvent): void {\n    const { removeOnSpill, revertOnSpill } = this.props;\n    if (removeOnSpill && !revertOnSpill) removeNode(evt.item);\n  }\n\n  onSelect(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const newList = [...list];\n    newList.forEach((item) => {\n      Object.assign(item, {\n        chosen: false,\n      });\n    });\n    evt.newIndicies.forEach((curr) => {\n      const index = curr.index;\n      if (index === -1) {\n        console.log(\n          `\"${evt.type}\" had indice of \"${curr.index}\", which is probably -1 and doesn't usually happen here.`\n        );\n        console.log(evt);\n        return;\n      }\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onDeselect(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const newList = [...list];\n    newList.forEach((item) => {\n      Object.assign(item, {\n        chosen: false,\n      });\n    });\n    evt.newIndicies.forEach((curr) => {\n      const index = curr.index;\n      if (index === -1) return;\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  }\n}\n\n// everything below this point can be removed\n// once @types has been merged. PR submited\ninterface MultiIndices {\n  multiDragElement: HTMLElement;\n  index: number;\n}\n\nexport interface MultiDragEvent extends SortableEvent {\n  // @todo - add this to @types\n  clones: HTMLElement[];\n  oldIndicies: MultiIndices[];\n  newIndicies: MultiIndices[];\n  swapItem: HTMLElement | null;\n}\n","import { PropsWithChildren } from \"react\";\nimport Sortable, { Options } from \"sortablejs\";\nimport { MultiDragEvent } from \"./react-sortable\";\nimport { AllMethodNames, ItemInterface, ReactSortableProps } from \"./types\";\n\n/**\n * Removes the `node` from the DOM\n * @param node\n */\nexport function removeNode(node: HTMLElement): void {\n  if (node.parentElement !== null) node.parentElement.removeChild(node);\n}\n\n/**\n * Inserts the `newChild` node at the given index in a parent\n * @param parent The parent HTML Element.\n * @param newChild A HTML eement to add as a child of the parent.\n * @param index index of the parent to place the new child in.\n */\nexport function insertNodeAt(\n  parent: HTMLElement,\n  newChild: HTMLElement,\n  index: number\n): void {\n  const refChild = parent.children[index] || null;\n  parent.insertBefore(newChild, refChild);\n}\n\n// @todo - create a dom handler function for arrays or not at all\n\n/** removes stuff from the dom in a nice order */\n// @todo - do I need parenElement?\nexport function handleDOMChanges<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  removeNodes(customs);\n  insertNodes(customs);\n}\n\nexport function removeNodes<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  customs.forEach((curr) => removeNode(curr.element));\n}\n\nexport function insertNodes<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  customs.forEach((curr) => {\n    insertNodeAt(curr.parentElement, curr.element, curr.oldIndex);\n  });\n}\n\nexport function createCustoms<T extends ItemInterface>(\n  evt: MultiDragEvent,\n  list: T[]\n): Normalized<T>[] {\n  const mode = getMode(evt);\n  const parentElement = { parentElement: evt.from };\n  let custom = [];\n  switch (mode) {\n    case \"normal\":\n      /* eslint-disable */\n      const item = {\n        element: evt.item,\n        newIndex: evt.newIndex!,\n        oldIndex: evt.oldIndex!,\n        parentElement: evt.from,\n      };\n      custom = [item];\n      break;\n    case \"swap\":\n      const drag: Input = {\n        element: evt.item,\n        oldIndex: evt.oldIndex!,\n        newIndex: evt.newIndex!,\n        ...parentElement,\n      };\n      const swap: Input = {\n        element: evt.swapItem!,\n        oldIndex: evt.newIndex!,\n        newIndex: evt.oldIndex!,\n        ...parentElement,\n      };\n      custom = [drag, swap];\n      break;\n    case \"multidrag\":\n      custom = evt.oldIndicies.map<Input>((curr, index) => ({\n        element: curr.multiDragElement,\n        oldIndex: curr.index,\n        newIndex: evt.newIndicies[index].index,\n        ...parentElement,\n      }));\n      break;\n  }\n  /* eslint-enable */\n\n  const customs = createNormalized(custom, list);\n  return customs;\n}\n\n/** moves items form old index to new index without breaking anything ideally. */\nexport function handleStateChanges<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[]\n): T[] {\n  const a = handleStateRemove(normalized, list);\n  const b = handleStateAdd(normalized, a);\n  return b;\n}\n\nexport function handleStateRemove<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[]\n): T[] {\n  const newList = [...list];\n  normalized\n    .concat()\n    .reverse()\n    .forEach((curr) => newList.splice(curr.oldIndex, 1));\n  return newList;\n}\n\nexport function handleStateAdd<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[],\n  evt?: Sortable.SortableEvent,\n  clone?: ((currentItem: T, evt: Sortable.SortableEvent) => T) | undefined\n): T[] {\n  const newList = [...list];\n  normalized.forEach((curr) => {\n    const newItem = clone && evt && clone(curr.item, evt);\n    newList.splice(curr.newIndex, 0, newItem || curr.item);\n  });\n  return newList;\n}\n\nexport function getMode(evt: MultiDragEvent): \"multidrag\" | \"swap\" | \"normal\" {\n  if (evt.oldIndicies && evt.oldIndicies.length > 0) return \"multidrag\";\n  if (evt.swapItem) return \"swap\";\n  return \"normal\";\n}\n\nexport function createNormalized<T extends ItemInterface>(\n  inputs: Input[],\n  list: T[]\n): Normalized<T>[] {\n  const normalized = inputs\n    .map<Normalized<T>>((curr) => ({ ...curr, item: list[curr.oldIndex] }))\n    .sort((a, b) => a.oldIndex - b.oldIndex);\n  return normalized;\n}\n\nexport interface Input {\n  parentElement: HTMLElement;\n  element: HTMLElement;\n  oldIndex: number;\n  newIndex: number;\n}\n\nexport interface Normalized<T> extends Input {\n  item: T;\n}\n\n/**\n * Removes the following group of properties from `props`,\n * leaving only `Sortable.Options` without any `on` methods.\n * @param props `ReactSortable.Props`\n */\nexport function destructurePropsForOptions<T>(\n  props: PropsWithChildren<ReactSortableProps<T>>\n): Exclude<Options, AllMethodNames> {\n  /* eslint-disable */\n  const {\n    // react sortable props\n    list,\n    setList,\n    children,\n    tag,\n    style,\n    className,\n    clone,\n    // sortable options that have methods we want to overwrite\n    onAdd,\n    onChange,\n    onChoose,\n    onClone,\n    onEnd,\n    onFilter,\n    onRemove,\n    onSort,\n    onStart,\n    onUnchoose,\n    onUpdate,\n    onMove,\n    onSpill,\n    onSelect,\n    onDeselect,\n    ...options\n  } = props;\n  /* eslint-enable */\n  return options;\n}\n\n/**\n * Construct a type with the properties of T except for those in type K.\n * Including this allows for backwards compatibility with earlier versions of TS.\n */\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n"]},"metadata":{},"sourceType":"script"}